<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube ç•™è¨€åˆ†æ</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

</head>
<style>
    html {
        scroll-behavior: smooth;
    }
</style>


<body class="p-4">
    <!-- å´é‚Šç›®éŒ„ -->
    <div
        style="position: fixed; top: 0; left: 0; height: 100vh; width: 180px; background-color: #f8f9fa; padding: 1rem; overflow-y: auto; border-right: 1px solid #ddd;">
        <h5>ğŸ“š ç›®éŒ„</h5>
        <ul class="nav flex-column">
            <li class="nav-item"><a class="nav-link" href="#upload">ğŸ“‚ ä¸Šå‚³æª”æ¡ˆ</a></li>
            <li class="nav-item"><a class="nav-link" href="#chart">ğŸ“ˆ æŠ˜ç·šåœ–</a></li>
            <li class="nav-item"><a class="nav-link" href="#top">ğŸ’¬ ç†±é–€ç•™è¨€</a></li>
            <li class="nav-item"><a class="nav-link" href="#stats">ğŸ‘¤ è§€çœ¾çµ±è¨ˆ</a></li>
        </ul>
    </div>

    <div class="container">
        <h2 class="mb-4">ğŸ“Š YouTube ç•™è¨€åˆ†æå·¥å…·</h2>

        <!-- ä¸Šå‚³ CSV æª”æ¡ˆ -->
        <div class="mb-3" id="upload">
            <label for="csvFile" class="form-label">ä¸Šå‚³ç•™è¨€ CSV æª”æ¡ˆï¼š</label>
            <input class="form-control" type="file" id="csvFile" accept=".csv">
        </div>
        <div class="mb-4">
            <button class="btn btn-primary" onclick="analyzeData()">é–‹å§‹åˆ†æ</button>
        </div>

        <!-- é—œéµå­—ç¯©é¸ -->
        <div class="mb-3">
            <label for="keywords" class="form-label">è¼¸å…¥ç¯©é¸é—œéµå­—ï¼ˆä»¥é€—è™Ÿåˆ†éš”ï¼‰ï¼š</label>
            <input class="form-control" type="text" id="keywords" placeholder="ä¾‹å¦‚ï¼šé™è½,é†¬è‚‰">
        </div>
        <!-- è§€çœ¾åç¨±ç¯©é¸ -->
        <div class="mb-3">
            <label for="userFilter" class="form-label">è¼¸å…¥è§€çœ¾åç¨±ï¼ˆå¯ç•™ç©ºï¼‰ï¼š</label>
            <input class="form-control" type="text" id="userFilter" placeholder="ä¾‹å¦‚ï¼šé™è½ã€é˜¿å¸ƒã€å°ç¾½...">
        </div>


        <div class="mb-5" id="chart">
            <h5>ğŸ“ˆ ç•™è¨€æ•¸èˆ‡æ™‚é–“æŠ˜ç·šåœ–</h5>
            <canvas id="timeChart"></canvas>
        </div>

        <div class="mb-5" id="top">
            <h5>ğŸ’¬ ç†±é–€ç•™è¨€</h5>
            <ul id="topComments" class="list-group"></ul>
        </div>

        <div class="mb-5" id="stats">
            <h5>ğŸ‘¤ è§€çœ¾ç•™è¨€çµ±è¨ˆ</h5>
            <table class="table table-bordered">
                <thead>
                    <tr>
                        <th>ä½¿ç”¨è€…</th>
                        <th>ç•™è¨€æ¬¡æ•¸</th>
                        <th>é¦–æ¬¡ç•™è¨€æ™‚é–“</th>
                        <th>æœ€å¾Œç•™è¨€æ™‚é–“</th>
                    </tr>
                </thead>
                <tbody id="userStats"></tbody>
            </table>
        </div>
    </div>

    <script>
        let allData = []
        function parseTimeToSeconds(t) {
            const isNegative = t.startsWith('-')
            const parts = t.replace('-', '').split(':').map(Number)
            let seconds = 0

            if (parts.length === 2) {
                seconds = parts[0] * 60 + parts[1]
            } else if (parts.length === 3) {
                seconds = parts[0] * 3600 + parts[1] * 60 + parts[2]
            }

            return isNegative ? -seconds : seconds
        }

        function formatSecondsToTime(sec) {
            const isNegative = sec < 0
            const abs = Math.abs(sec)
            const h = Math.floor(abs / 3600)
            const m = Math.floor((abs % 3600) / 60)
            const s = abs % 60
            const parts = h > 0 ? [h, m, s] : [m, s]
            return (isNegative ? '-' : '') + parts.map(p => String(p).padStart(2, '0')).join(':')
        }

        function aggregateData(rawSeconds, binSize = 30) {
            const bins = {}
            rawSeconds.forEach(sec => {
                const bin = Math.floor(sec / binSize) * binSize
                bins[bin] = (bins[bin] || 0) + 1
            })
            const sortedBins = Object.keys(bins).map(Number).sort((a, b) => a - b)
            const labels = sortedBins.map(s => formatSecondsToTime(s))
            const values = sortedBins.map(s => bins[s])
            return { labels, values }
        }

        function analyzeData() {
            const keywordInput = document.getElementById("keywords").value.trim()
            const keywords = keywordInput.split(',').map(k => k.trim()).filter(k => k)
            const userFilter = document.getElementById("userFilter").value.trim().toLowerCase()

            const filtered = allData.filter(row =>
                (keywords.length === 0 || keywords.some(k => row.comment.includes(k))) &&
                (userFilter === '' || row.user.toLowerCase().includes(userFilter))
            )

            // ç•™è¨€æ•¸èˆ‡æ™‚é–“åœ–è¡¨è³‡æ–™æ•´ç†
            const rawTimeData = []
            filtered.forEach(row => {
                const sec = parseTimeToSeconds(row.time)
                rawTimeData.push(sec)
            })

            function parseTimeToSeconds(t) {
                const isNegative = t.startsWith('-')
                const parts = t.replace('-', '').split(':').map(Number)
                let seconds = 0

                if (parts.length === 2) {
                    // mm:ss
                    seconds = parts[0] * 60 + parts[1]
                } else if (parts.length === 3) {
                    // hh:mm:ss
                    seconds = parts[0] * 3600 + parts[1] * 60 + parts[2]
                }

                return isNegative ? -seconds : seconds
            }

            // å°‡æ™‚é–“ä»¥ç§’ç‚ºåŸºæº–æ’åº
            const { labels, values } = aggregateData(rawTimeData, 30) // åˆå§‹ 30 ç§’é–“è·
            renderLineChart(labels, values, rawTimeData)

            // ç•™è¨€å…§å®¹æ’åºï¼ˆä¸å«ç©ºç™½ï¼‰
            const commentMap = {}
            filtered.forEach(row => {
                const text = row.comment.trim()
                if (text === '') return
                commentMap[text] = (commentMap[text] || 0) + 1
            })
            const topComments = Object.entries(commentMap).sort((a, b) => b[1] - a[1])
            renderTopComments(topComments)

            // ä½¿ç”¨è€…ç•™è¨€æ¬¡æ•¸ + é¦–æ¬¡/æœ€å¾Œç•™è¨€æ™‚é–“
            const userMap = {}
            filtered.forEach(row => {
                if (!userMap[row.user]) {
                    userMap[row.user] = { count: 1, first: row.time, last: row.time, avatar: row.avatar }
                } else {
                    userMap[row.user].count++
                    const rowTimeSec = parseTimeToSeconds(row.time)
                    const firstTimeSec = parseTimeToSeconds(userMap[row.user].first)
                    const lastTimeSec = parseTimeToSeconds(userMap[row.user].last)

                    userMap[row.user].first = rowTimeSec < firstTimeSec ? row.time : userMap[row.user].first
                    userMap[row.user].last = rowTimeSec > lastTimeSec ? row.time : userMap[row.user].last
                }
            })
            const sortedUsers = Object.entries(userMap).sort((a, b) => b[1].count - a[1].count)
            renderUserStats(sortedUsers)
        }

        function renderLineChart(labels, values, rawTimeData) {
            const ctx = document.getElementById("timeChart").getContext("2d")
            if (window.lineChart) window.lineChart.destroy()

            window.lineChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels,
                    datasets: [{
                        label: "ç•™è¨€æ•¸",
                        data: values,
                        fill: false,
                        borderColor: '#32a1ce',
                        tension: 0.1,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        zoom: {
                            zoom: {
                                wheel: { enabled: true },
                                pinch: { enabled: true },
                                mode: 'x',
                                onZoomComplete({ chart }) {
                                    const xScale = chart.scales.x
                                    const minLabel = xScale.min
                                    const maxLabel = xScale.max

                                    const minSec = parseTimeToSeconds(minLabel)
                                    const maxSec = parseTimeToSeconds(maxLabel)
                                    const visibleRange = maxSec - minSec
                                    const binSize = Math.max(1, Math.floor(visibleRange / 100)) // æ§åˆ¶ç´„ 100 å€‹é»å…§

                                    const { labels, values } = aggregateData(rawTimeData, binSize)
                                    renderLineChart(labels, values, rawTimeData)
                                }
                            },
                            pan: {
                                enabled: true,
                                mode: 'x'
                            }
                        },
                        legend: {
                            display: true
                        },
                        tooltip: {
                            callbacks: {
                                title: function (tooltipItems) {
                                    return tooltipItems[0].label
                                },
                                label: function (tooltipItem) {
                                    return `ç•™è¨€æ•¸: ${tooltipItem.formattedValue}`
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'æ™‚é–“' }
                        },
                        y: {
                            title: { display: true, text: 'ç•™è¨€æ•¸' },
                            beginAtZero: true
                        }
                    }
                }
            })
        }

        function renderTopComments(comments) {
            const list = document.getElementById("topComments")
            list.innerHTML = ''

            comments.forEach(([text, count], index) => {
                const li = document.createElement("li")
                li.className = "list-group-item d-flex justify-content-between align-items-center"

                // å·¦å´ï¼šç·¨è™Ÿ + å…§å®¹
                const leftDiv = document.createElement("div")
                leftDiv.className = "d-flex align-items-center"

                const indexSpan = document.createElement("span")
                indexSpan.textContent = index + 1
                indexSpan.style.width = '2rem'
                indexSpan.style.fontWeight = 'bold'
                indexSpan.style.flexShrink = '0'

                const contentSpan = document.createElement("span")
                contentSpan.textContent = `${text}ï¼ˆ${count}ï¼‰`
                contentSpan.style.marginLeft = '0.5rem'

                leftDiv.appendChild(indexSpan)
                leftDiv.appendChild(contentSpan)

                // å³å´ï¼šé ­åƒå€
                const avatarDiv = document.createElement("div")
                avatarDiv.className = "d-flex align-items-center flex-wrap"
                avatarDiv.style.gap = '4px'

                const matchedUsers = allData.filter(row => row.comment.trim() === text)
                const seenUsers = new Set()
                const uniqueUsers = []

                for (let row of matchedUsers) {
                    if (!seenUsers.has(row.user)) {
                        seenUsers.add(row.user)
                        uniqueUsers.push(row)
                    }
                }

                const maxDisplay = 8
                const extraCount = uniqueUsers.length - maxDisplay

                uniqueUsers.slice(0, maxDisplay).forEach(user => {
                    const img = document.createElement("img")
                    img.src = user.avatar
                    img.alt = user.user
                    img.title = user.user
                    img.style.width = '36px'
                    img.style.height = '36px'
                    img.style.borderRadius = '50%'
                    img.style.objectFit = 'cover'
                    avatarDiv.appendChild(img)
                })

                // é¡¯ç¤ºã€Œ+Nã€æç¤º
                if (extraCount > 0) {
                    const moreSpan = document.createElement("span")
                    moreSpan.textContent = `+${extraCount}`
                    moreSpan.style.marginLeft = '6px'
                    moreSpan.style.fontWeight = 'bold'
                    moreSpan.style.fontSize = '14px'
                    moreSpan.style.color = '#555'
                    avatarDiv.appendChild(moreSpan)
                }

                li.appendChild(leftDiv)
                li.appendChild(avatarDiv)
                list.appendChild(li)
            })
        }

        function renderUserStats(users) {
            const tbody = document.getElementById("userStats")
            tbody.innerHTML = ''
            users.forEach(([user, stat]) => {
                const tr = document.createElement("tr")
                tr.innerHTML = `<td><img src="${stat.avatar}" alt="${user}" style="width:40px;height:40px;border-radius:50%;object-fit:cover;margin-right:8px;">${user}</td><td>${stat.count}</td><td>${stat.first}</td><td>${stat.last}</td>`
                tbody.appendChild(tr)
            })
        }

        document.getElementById("csvFile").addEventListener("change", function (e) {
            Papa.parse(e.target.files[0], {
                header: true,
                skipEmptyLines: true,
                complete: function (results) {
                    allData = results.data.map(r => ({
                        time: r['å½±ç‰‡å…§æ™‚é–“'],
                        user: r['ä½¿ç”¨è€…'],
                        comment: r['ç•™è¨€'],
                        avatar: r['é ­åƒé€£çµ']
                    }))
                    // alert("âœ… æª”æ¡ˆä¸Šå‚³æˆåŠŸï¼Œå¯é–‹å§‹åˆ†æï¼")
                }
            })
        })
    </script>
</body>

</html>